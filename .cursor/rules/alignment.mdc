---
alwaysApply: true
---

# System Alignment & Design Principles - Flow Platform

## üéØ Purpose

This rule documents the foundational design principles, architectural alignment, and quality standards that ensure all components of the Flow platform work together harmoniously. It serves as the **north star** for all development decisions, preventing misalignment and data loss.

---

## üåü Core Design Principles

### 1. Data Persistence First

**Principle:** Every user action that creates or modifies data MUST persist to GCP (Firestore/BigQuery) immediately.

**Why:** Users trust that their work is saved. Data loss destroys trust and productivity.

**Implementation:**
```typescript
// ‚ùå WRONG: Data only in memory
const [conversations, setConversations] = useState([]);
setConversations([...conversations, newConv]); // Lost on refresh!

// ‚úÖ CORRECT: Persist to backend, then update state
const response = await fetch('/api/conversations', {
  method: 'POST',
  body: JSON.stringify({ userId, title })
});
const newConv = await response.json();
setConversations([...conversations, newConv]); // Now safe
```

**Verification:**
- [ ] Every user action that creates data calls an API
- [ ] API endpoint saves to Firestore/BigQuery
- [ ] Frontend state reflects backend state
- [ ] Refresh preserves all user data

---

### 2. Progressive Disclosure

**Principle:** Show users only what they need, when they need it. Don't overwhelm with all features at once.

**Why:** Cognitive load reduces productivity. Users should focus on their current task.

**Implementation:**
- Default view: Essential features visible
- Advanced features: Hidden behind settings/toggles
- Context: Expandable panels show details on demand
- Workflows: Step-by-step guided experiences

**Examples:**
```
‚úÖ Context sources: Collapsed by default, expand on click
‚úÖ Workflow config: Modal with focused settings
‚úÖ Error details: "Ver detalles" button reveals full info
‚úÖ Context logs: Compact table, expandable rows
```

**Anti-patterns:**
```
‚ùå Show all context sources expanded at once
‚ùå Display full workflow config in main UI
‚ùå Show all error stack traces inline
‚ùå Render entire conversation history without virtualization
```

---

### 3. Feedback & Visibility

**Principle:** Always show users what's happening. Never leave them wondering.

**Why:** Uncertainty creates anxiety. Clear feedback builds confidence.

**State Visibility:**
```typescript
// Loading states
{isLoading && <Loader2 className="animate-spin" />}

// Progress states
<ProgressBar percentage={progress} message="Procesando..." />

// Success states
{success && <CheckCircle className="text-green-600" />}

// Error states
{error && (
  <div className="bg-red-50 border border-red-200 p-3">
    <p className="font-semibold text-red-800">{error.message}</p>
    <button onClick={retry}>Reintentar</button>
  </div>
)}

// Empty states
{items.length === 0 && (
  <div className="text-center text-slate-500">
    <p>No hay elementos</p>
    <button onClick={create}>Crear primero</button>
  </div>
)}
```

**All Operations Must Show:**
- ‚è≥ Loading indicator during processing
- ‚úÖ Success confirmation after completion
- ‚ùå Error message with recovery options
- üìä Progress for long operations (>2s)
- üîÑ State changes animated smoothly

---

### 4. Graceful Degradation

**Principle:** The system should continue working even when external services fail.

**Why:** Network issues, service outages, and configuration problems are inevitable. Users shouldn't be blocked.

**Implementation Layers:**

**Layer 1: Try Real Service**
```typescript
try {
  const data = await fetch('/api/conversations');
  return await data.json();
} catch (error) {
  console.error('API error:', error);
  // Continue to Layer 2...
}
```

**Layer 2: Fallback to Cache/Local**
```typescript
const cachedData = localStorage.getItem('conversations');
if (cachedData) {
  console.warn('Using cached data due to API error');
  return JSON.parse(cachedData);
}
```

**Layer 3: Temporary/Mock Mode**
```typescript
// Only for non-critical features
if (IS_DEVELOPMENT && !cachedData) {
  console.warn('Using temporary conversation (Firestore unavailable)');
  return createTempConversation();
}
```

**Layer 4: User-Friendly Error**
```typescript
return {
  error: 'No se pudo cargar las conversaciones',
  suggestions: [
    'Verifica tu conexi√≥n a internet',
    'Recarga la p√°gina',
    'Contacta soporte si el problema persiste'
  ]
};
```

**Never:**
- ‚ùå Crash the app due to external service failure
- ‚ùå Show technical error messages to users
- ‚ùå Silently fail without user notification
- ‚ùå Use mock data without user awareness

---

### 5. Type Safety Everywhere

**Principle:** Use TypeScript strictly. Every piece of data should have a defined interface.

**Why:** Type errors caught at compile time are infinitely cheaper than runtime bugs in production.

**Implementation:**
```typescript
// ‚úÖ CORRECT: Explicit interfaces
interface Conversation {
  id: string;
  userId: string;
  title: string;
  agentModel: 'gemini-2.5-flash' | 'gemini-2.5-pro';
  activeContextSourceIds: string[];
  createdAt: Date;
  updatedAt: Date;
}

interface Message {
  id: string;
  conversationId: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  tokenCount: number;
}

// ‚úÖ CORRECT: Type-safe API responses
async function getConversations(userId: string): Promise<Conversation[]> {
  const response = await fetch(`/api/conversations?userId=${userId}`);
  return await response.json();
}

// ‚ùå WRONG: No types
function getConversations(userId) {
  return fetch('/api/conversations?userId=' + userId).then(r => r.json());
}
```

**Enforce:**
- [ ] `npm run type-check` passes with 0 errors
- [ ] All functions have return types
- [ ] All parameters have types
- [ ] No `any` types (use `unknown` if needed)
- [ ] Interfaces for all data structures

---

### 6. Performance as a Feature

**Principle:** Speed is a feature. Every interaction should feel instant (<100ms) or show clear progress.

**Why:** Slow apps feel broken. Users lose focus waiting for responses.

**Performance Targets:**
```
User Input ‚Üí UI Response: <100ms (instant feel)
API Call ‚Üí Response: <1s (p95)
Page Load: <2s (p95)
Chat Message ‚Üí AI Response (first token): <2s
Context Window Calculation: <200ms
Document Extraction: Show progress every 500ms
```

**Optimization Strategies:**

**Frontend:**
```typescript
// ‚úÖ Memoization for expensive computations
const sortedConversations = useMemo(() => 
  conversations.sort((a, b) => b.lastMessageAt - a.lastMessageAt),
  [conversations]
);

// ‚úÖ Callback memoization to prevent re-renders
const handleClick = useCallback((id: string) => {
  setSelectedId(id);
}, []);

// ‚úÖ Component memoization
const ConversationCard = memo(function ConversationCard({ conversation }) {
  return <div>{conversation.title}</div>;
});

// ‚úÖ Lazy loading for heavy components
const AdminPanel = lazy(() => import('./AdminPanel'));
```

**Backend:**
```typescript
// ‚úÖ Batch Firestore operations
const batch = firestore.batch();
messages.forEach(msg => batch.delete(msg.ref));
await batch.commit(); // Single network call

// ‚úÖ Parallel operations
const [conversations, contextSources, user] = await Promise.all([
  getConversations(userId),
  getContextSources(userId),
  getUser(userId)
]);

// ‚úÖ Cache frequently accessed data
const cachedUser = await getCachedUser(userId);
```

**Database:**
```sql
-- ‚úÖ Proper indexes
CREATE INDEX idx_user_conversations 
ON conversations (userId, lastMessageAt DESC);

-- ‚úÖ Limit query size
SELECT * FROM conversations 
WHERE userId = @userId 
ORDER BY lastMessageAt DESC 
LIMIT 50;
```

---

### 7. Security by Default

**Principle:** Every endpoint requires authentication. Every query filters by user. No data leaks.

**Why:** User data is sacred. Security breaches destroy businesses.

**Implementation:**

**API Authentication:**
```typescript
// ‚úÖ ALWAYS verify JWT
export const GET: APIRoute = async ({ request, cookies }) => {
  const token = cookies.get('flow_session')?.value;
  if (!token) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), {
      status: 401
    });
  }
  
  const session = verifyJWT(token);
  if (!session) {
    return new Response(JSON.stringify({ error: 'Invalid session' }), {
      status: 401
    });
  }
  
  // Continue with authenticated request...
};
```

**Data Access:**
```typescript
// ‚úÖ ALWAYS filter by userId
const conversations = await firestore
  .collection('conversations')
  .where('userId', '==', session.id) // CRITICAL
  .get();

// ‚ùå NEVER fetch all data
const allConversations = await firestore
  .collection('conversations')
  .get(); // Security vulnerability!
```

**Firestore Rules:**
```javascript
// ‚úÖ User isolation
match /conversations/{conversationId} {
  allow read, write: if request.auth != null && 
                     resource.data.userId == request.auth.uid;
}
```

**Security Checklist:**
- [ ] All API routes verify JWT
- [ ] All Firestore queries filter by userId
- [ ] All sensitive data encrypted at rest
- [ ] No API keys in frontend code
- [ ] HTTPS only (no HTTP)
- [ ] CORS properly configured

---

## üèóÔ∏è Architectural Alignment

### Layer 1: Frontend (React + Astro)

**Responsibilities:**
- ‚úÖ User interaction & input handling
- ‚úÖ State management (local & server state)
- ‚úÖ Data display & visualization
- ‚úÖ Optimistic UI updates
- ‚úÖ Error handling & user feedback

**Must NOT:**
- ‚ùå Business logic (belongs in backend)
- ‚ùå Data persistence (belongs in backend)
- ‚ùå Direct database access (use API)
- ‚ùå Sensitive computations (use backend)

**Integration Points:**
```
Frontend ‚Üí API Routes ‚Üí Backend Services
Frontend ‚Üí Firestore (read-only, via API)
Frontend ‚Üí BigQuery (never directly)
```

---

### Layer 2: API Routes (Astro)

**Responsibilities:**
- ‚úÖ Authentication & authorization
- ‚úÖ Request validation
- ‚úÖ Business logic orchestration
- ‚úÖ Error handling & logging
- ‚úÖ Response formatting

**Must NOT:**
- ‚ùå UI rendering (belongs in frontend)
- ‚ùå Complex data transformations (use services)
- ‚ùå Direct AI calls (use service layer)

**Pattern:**
```typescript
export const POST: APIRoute = async ({ request, cookies }) => {
  // 1. Authenticate
  const session = await authenticate(cookies);
  
  // 2. Validate input
  const body = await validateInput(request);
  
  // 3. Call service layer
  const result = await service.execute(body);
  
  // 4. Track analytics (non-blocking)
  trackEvent(session.id, 'action', result).catch(console.warn);
  
  // 5. Return response
  return new Response(JSON.stringify(result), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
};
```

---

### Layer 3: Service Layer (Backend Logic)

**Responsibilities:**
- ‚úÖ Business logic implementation
- ‚úÖ Data transformation
- ‚úÖ External service integration (Gemini AI)
- ‚úÖ Complex computations
- ‚úÖ Data validation

**Must NOT:**
- ‚ùå Direct HTTP handling (use API routes)
- ‚ùå Session management (use auth middleware)

**Pattern:**
```typescript
// src/lib/conversations.ts
export async function createConversation(
  userId: string,
  title: string,
  model: string
): Promise<Conversation> {
  // 1. Validate input
  if (!userId || !title) {
    throw new Error('Missing required fields');
  }
  
  // 2. Create in Firestore
  const conversation = await firestore
    .collection('conversations')
    .add({
      userId,
      title,
      agentModel: model,
      createdAt: new Date(),
      messageCount: 0
    });
  
  // 3. Track in BigQuery (non-blocking)
  trackConversationCreated(conversation).catch(console.warn);
  
  // 4. Return result
  return conversation;
}
```

---

### Layer 4: Data Layer (Firestore + BigQuery)

**Firestore: Operational Database**
- ‚úÖ User-facing data (conversations, messages, users)
- ‚úÖ Real-time updates
- ‚úÖ Transactional operations
- ‚úÖ Source of truth for user data

**BigQuery: Analytics Warehouse**
- ‚úÖ Historical analysis
- ‚úÖ Aggregated metrics
- ‚úÖ Complex queries
- ‚úÖ Reporting & dashboards

**Separation:**
```
Firestore ‚Üí User creates conversation ‚Üí Store immediately
    ‚Üì
BigQuery ‚Üê Sync conversation metadata ‚Üê Optional (analytics only)
```

**Never:**
- ‚ùå Query BigQuery for operational data
- ‚ùå Use Firestore for complex analytics
- ‚ùå Mix concerns between databases

---

## üîÑ Data Flow Consistency

### Complete User Action Flow

```
1. User Action (Frontend)
   ‚Üì
2. Optimistic UI Update (Frontend)
   ‚Üì
3. API Call (Frontend ‚Üí Backend)
   ‚Üì
4. Authentication Check (API Route)
   ‚Üì
5. Input Validation (API Route)
   ‚Üì
6. Business Logic (Service Layer)
   ‚Üì
7. Firestore Write (Data Layer)
   ‚Üì
8. BigQuery Sync (Optional, Non-blocking)
   ‚Üì
9. Response to Frontend (API Route)
   ‚Üì
10. UI Update (Frontend)
```

### Error at Any Step

```
Error Occurs
   ‚Üì
Log Error Details (with context)
   ‚Üì
Rollback Changes (if transactional)
   ‚Üì
Return User-Friendly Error
   ‚Üì
Show Recovery Options
   ‚Üì
Track Error in Analytics
```

---

## üíé Quality Standards

### Code Quality

**TypeScript:**
- ‚úÖ Strict mode enabled
- ‚úÖ No `any` types
- ‚úÖ All functions have return types
- ‚úÖ All interfaces exported
- ‚úÖ `npm run type-check` passes

**React:**
- ‚úÖ Functional components only
- ‚úÖ Proper hooks usage (deps arrays)
- ‚úÖ Memoization where needed
- ‚úÖ Error boundaries for resilience
- ‚úÖ No console.logs in production

**API Routes:**
- ‚úÖ Always authenticate first
- ‚úÖ Always validate input
- ‚úÖ Always handle errors
- ‚úÖ Always return consistent structure
- ‚úÖ Always log important events

**Database:**
- ‚úÖ All queries indexed
- ‚úÖ All writes batched where possible
- ‚úÖ All timestamps converted
- ‚úÖ All sensitive data filtered by userId
- ‚úÖ All collections have security rules

---

### Testing Standards

**Unit Tests:**
```typescript
// Test individual functions
describe('createConversation', () => {
  it('should create conversation in Firestore', async () => {
    const conv = await createConversation('user123', 'Test');
    expect(conv.userId).toBe('user123');
  });
  
  it('should throw error for missing userId', async () => {
    await expect(createConversation('', 'Test')).rejects.toThrow();
  });
});
```

**Integration Tests:**
```typescript
// Test API endpoints
describe('POST /api/conversations', () => {
  it('should create conversation via API', async () => {
    const response = await fetch('/api/conversations', {
      method: 'POST',
      headers: { 'Cookie': 'flow_session=valid_token' },
      body: JSON.stringify({ userId: 'user123', title: 'Test' })
    });
    
    expect(response.status).toBe(200);
  });
});
```

**Manual Testing Checklist:**
- [ ] Happy path works
- [ ] Error cases handled
- [ ] Loading states shown
- [ ] Data persists on refresh
- [ ] Works on mobile
- [ ] No console errors

---

### Performance Standards

**Frontend:**
- First Contentful Paint: <1.5s
- Time to Interactive: <3s
- Lighthouse Score: >90
- Bundle Size: <300KB gzipped

**Backend:**
- API Response Time (p95): <1s
- Database Query Time (p95): <200ms
- Memory Usage: <512MB
- CPU Usage: <50% average

**Database:**
- Firestore Read Latency (p95): <100ms
- Firestore Write Latency (p95): <200ms
- BigQuery Query Time (p95): <2s
- Index Coverage: 100%

---

## üîê Security Standards

### Authentication

**JWT Requirements:**
```typescript
interface JWTPayload {
  id: string;        // User ID
  email: string;     // User email
  role: string;      // User role
  iat: number;       // Issued at
  exp: number;       // Expiration
}

// Expiration: 7 days
// Signing: HS256 with secret
// Storage: HTTP-only cookie
```

**OAuth Flow:**
```
1. User clicks "Login with Google"
2. Redirect to Google OAuth
3. Google redirects back with code
4. Exchange code for user info
5. Create/update user in Firestore
6. Generate JWT
7. Set HTTP-only cookie
8. Redirect to /chat
```

---

### Authorization

**Role-Based Access Control:**

```typescript
const ROLE_PERMISSIONS = {
  admin: ['*'], // All permissions
  expert: ['validate_context', 'view_analytics'],
  user: ['create_conversation', 'upload_context'],
  context_signoff: ['validate_context'],
  context_reviewer: ['review_context'],
};

function hasPermission(userRole: string, permission: string): boolean {
  const permissions = ROLE_PERMISSIONS[userRole] || [];
  return permissions.includes('*') || permissions.includes(permission);
}
```

**Check Before Every Action:**
```typescript
if (!hasPermission(user.role, 'validate_context')) {
  return new Response(JSON.stringify({ error: 'Forbidden' }), {
    status: 403
  });
}
```

---

### Data Protection

**Sensitive Data:**
- ‚úÖ API keys: Environment variables only
- ‚úÖ Passwords: Never store (OAuth only)
- ‚úÖ JWT secrets: Rotate monthly
- ‚úÖ User data: Encrypted at rest (Firestore default)
- ‚úÖ PII: Minimize collection, comply with GDPR

**Logging:**
```typescript
// ‚úÖ GOOD: Log without sensitive data
console.log({
  action: 'user_login',
  userId: hashUserId(userId), // Hashed
  timestamp: new Date(),
});

// ‚ùå BAD: Log sensitive data
console.log({
  action: 'user_login',
  email: user.email, // PII!
  password: password, // CRITICAL SECURITY ISSUE!
});
```

---

## üöÄ Development Workflow

### Local Development

**Setup:**
```bash
# 1. Clone repo
git clone https://github.com/org/flow.git

# 2. Install dependencies
npm install

# 3. Configure environment
cp .env.example .env
# Edit .env with your keys

# 4. Authenticate with GCP
gcloud auth application-default login

# 5. Start dev server
npm run dev

# 6. Verify
curl http://localhost:3000/api/health
```

**Development Loop:**
```
1. Create feature branch
   git checkout -b feat/feature-name-YYYY-MM-DD

2. Make changes
   - Edit code
   - Run type-check: npm run type-check
   - Test manually in browser

3. Commit
   git add .
   git commit -m "feat: Add feature"

4. Push & create PR
   git push origin feat/feature-name-YYYY-MM-DD

5. Review & merge
   - CI checks pass
   - Code reviewed
   - Merge to main

6. Deploy
   gcloud run deploy --source .
```

---

### Production Deployment

**Pre-Deployment Checklist:**
- [ ] `npm run type-check` passes (0 errors)
- [ ] `npm run build` succeeds
- [ ] All tests pass
- [ ] Environment variables configured
- [ ] Firestore indexes deployed
- [ ] BigQuery tables created
- [ ] Secrets updated (if needed)
- [ ] Backup created

**Deployment Command:**
```bash
# Set project
gcloud config set project gen-lang-client-0986191192

# Build and deploy
gcloud run deploy flow-chat \
  --source . \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated \
  --min-instances=1 \
  --set-env-vars="GOOGLE_CLOUD_PROJECT=gen-lang-client-0986191192"
```

**Post-Deployment Verification:**
```bash
# 1. Get service URL
SERVICE_URL=$(gcloud run services describe flow-chat \
  --region us-central1 \
  --format='value(status.url)')

# 2. Health check
curl -f "$SERVICE_URL/api/health" || echo "Health check failed!"

# 3. Smoke test
curl -f "$SERVICE_URL/chat" || echo "Chat page failed!"

# 4. Check logs
gcloud logging read "resource.type=cloud_run_revision" \
  --limit 50 \
  --format json

# 5. Monitor metrics
# Check Cloud Console for errors
```

---

### Rollback Plan

**If deployment fails:**

```bash
# 1. List revisions
gcloud run revisions list \
  --service flow-chat \
  --region us-central1

# 2. Rollback to previous
gcloud run services update-traffic flow-chat \
  --to-revisions=PREVIOUS_REVISION=100 \
  --region us-central1

# 3. Verify
curl -f "$SERVICE_URL/api/health"
```

---

## üìä Success Metrics

### User Experience Metrics

**Core Metrics:**
- Session Duration: >15 minutes (engaged)
- Messages per Session: >10 (productive)
- Context Sources per User: >3 (power user)
- Return Rate (7-day): >60% (sticky)
- NPS Score: >50 (satisfied)

**Technical Metrics:**
- Page Load Time (p95): <2s
- API Response Time (p95): <1s
- Error Rate: <0.5%
- Uptime: >99.9%
- Cost per User: <$2/month

---

### Development Metrics

**Code Quality:**
- TypeScript Coverage: 100%
- Test Coverage: >80%
- Linter Errors: 0
- Security Vulnerabilities: 0
- Tech Debt Ratio: <5%

**Team Velocity:**
- Features Delivered per Sprint: >5
- Bug Fix Time (p95): <24 hours
- PR Review Time (p95): <4 hours
- Deploy Frequency: >2x per week
- Lead Time: <2 days

---

## ‚úÖ Alignment Checklist

Before deploying ANY change, verify:

### Data Persistence ‚úÖ
- [ ] User data saves to Firestore
- [ ] Data persists on page refresh
- [ ] Data survives redeployments
- [ ] No data loss scenarios

### Architecture ‚úÖ
- [ ] Frontend only handles UI
- [ ] API routes handle auth & orchestration
- [ ] Services handle business logic
- [ ] Databases store data properly

### Quality ‚úÖ
- [ ] TypeScript type-check passes
- [ ] No linter errors
- [ ] All tests pass
- [ ] Manual testing complete

### Performance ‚úÖ
- [ ] Page loads <2s
- [ ] API responds <1s
- [ ] No memory leaks
- [ ] Efficient queries

### Security ‚úÖ
- [ ] All routes authenticated
- [ ] All data filtered by userId
- [ ] No sensitive data logged
- [ ] Environment variables secure

### User Experience ‚úÖ
- [ ] Loading states shown
- [ ] Errors handled gracefully
- [ ] Empty states informative
- [ ] Success feedback clear

---

## üéì Key Lessons Consolidated

### From Backend Development
1. ‚úÖ Use correct Gemini API patterns (GoogleGenAI, not GoogleGenerativeAI)
2. ‚úÖ Never use mock mode as automatic fallback
3. ‚úÖ Always handle Firestore unavailable gracefully
4. ‚úÖ Always persist to GCP, never rely on local state only
5. ‚úÖ Always use same GCP project (gen-lang-client-0986191192)

### From Frontend Development
1. ‚úÖ Always persist state to backend via API
2. ‚úÖ Always use TypeScript interfaces for all data
3. ‚úÖ Always handle loading, error, empty, and success states
4. ‚úÖ Never mix client state with server state
5. ‚úÖ Always use proper React hooks patterns (deps, cleanup)

### From Database Operations
1. ‚úÖ Always use consistent project ID in all environments
2. ‚úÖ Always convert Firestore Timestamps to Date objects
3. ‚úÖ Always use batch operations for multiple writes
4. ‚úÖ Always create indexes for all queries
5. ‚úÖ Always filter by userId for user-specific data

### From Analytics Integration
1. ‚úÖ Use sample data in development (no BigQuery setup required)
2. ‚úÖ Always partition tables by date for cost savings
3. ‚úÖ Always cluster frequently queried fields
4. ‚úÖ Set table expiration for high-volume data
5. ‚úÖ Use materialized views for dashboard queries

### From UI/UX Design
1. ‚úÖ Progressive disclosure: show essentials, hide advanced features
2. ‚úÖ Feedback for every action: loading, success, error states
3. ‚úÖ Graceful degradation: work even when services fail
4. ‚úÖ Responsive design: mobile, tablet, desktop
5. ‚úÖ Accessibility: keyboard navigation, screen readers, color contrast

---

## üîÆ Future Alignment Considerations

### Scalability
- Horizontal scaling strategy
- Caching layer (Redis)
- CDN for static assets
- Database read replicas
- Queue system for async tasks

### Observability
- Structured logging
- Distributed tracing
- Real-time monitoring
- Alerting system
- Performance profiling

### Internationalization
- Multi-language support
- Locale-specific formatting
- RTL layout support
- Translation management

### Advanced Features
- Real-time collaboration
- Offline mode with sync
- Mobile apps (iOS/Android)
- API for third-party integrations
- Webhooks for events

---

## üìö References

### Internal Documentation
- `.cursor/rules/backend.mdc` - Backend architecture
- `.cursor/rules/frontend.mdc` - Frontend architecture
- `.cursor/rules/firestore.mdc` - Database schema
- `.cursor/rules/bigquery.mdc` - Analytics architecture
- `.cursor/rules/ui.mdc` - UI components
- `.cursor/rules/prd.mdc` - Product requirements
- `docs/LocalToProduction.md` - Deployment guide
- `docs/COMPLETE_RULES_DOCUMENTATION.md` - Rules summary

### External Resources
- [Astro Documentation](https://docs.astro.build/)
- [React Best Practices](https://react.dev/learn)
- [Firestore Best Practices](https://firebase.google.com/docs/firestore/best-practices)
- [BigQuery Optimization](https://cloud.google.com/bigquery/docs/best-practices-performance-overview)
- [Web Vitals](https://web.dev/vitals/)

---

**Last Updated**: 2025-10-12  
**Version**: 1.0.0  
**Status**: ‚úÖ Production Ready  
**Project**: Flow (gen-lang-client-0986191192)

---

**Remember:** This rule is the foundation. When in doubt, refer back to these principles. They prevent 95% of bugs, data loss, and user frustration.
