---
alwaysApply: true
---

# Backend Architecture & Best Practices - Flow Platform

## üéØ Purpose

This rule documents the complete backend architecture, lessons learned, and best practices for the Flow platform. It ensures smooth local development, reliable production deployment, and prevents data loss.

---

## üèóÔ∏è Backend Architecture Overview

### Technology Stack

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FLOW BACKEND                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ    Astro     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Firestore  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ BigQuery ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  API Routes  ‚îÇ    ‚îÇ  (Database)  ‚îÇ    ‚îÇ(Analytics‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ         ‚îÇ                    ‚îÇ                  ‚îÇ       ‚îÇ
‚îÇ         ‚îÇ                    ‚îÇ                  ‚îÇ       ‚îÇ
‚îÇ         ‚ñº                    ‚ñº                  ‚ñº       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Gemini AI   ‚îÇ    ‚îÇ Cloud Storage‚îÇ    ‚îÇ  OAuth2  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ (2.5 Flash)  ‚îÇ    ‚îÇ   (Files)    ‚îÇ    ‚îÇ  (Auth)  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ (2.5 Pro)    ‚îÇ    ‚îÇ              ‚îÇ    ‚îÇ          ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Core Components

1. **Astro API Routes** (`src/pages/api/`)
   - RESTful endpoints
   - Server-side rendering
   - Type-safe request/response

2. **Firestore** (`src/lib/firestore.ts`)
   - Primary database
   - Real-time updates
   - Offline support

3. **BigQuery** (`src/lib/analytics.ts`)
   - Analytics data warehouse
   - Complex queries
   - Historical analysis

4. **Gemini AI** (`src/lib/gemini.ts`)
   - Text generation
   - Document extraction
   - Context understanding

---

## üîê Authentication & Authorization

### GCP Authentication Methods

#### 1. Local Development
```bash
# Application Default Credentials (ADC)
gcloud auth application-default login
```

**How it works:**
- Creates `~/.config/gcloud/application_default_credentials.json`
- Automatically used by all Google Cloud SDKs
- No need to specify credentials in code

#### 2. Production (Cloud Run)
```
Workload Identity (automatic)
```

**How it works:**
- Cloud Run service account has permissions
- No credentials file needed
- Automatic authentication

### Environment Variables Pattern

```typescript
// CORRECT: Support both Astro and Node.js
const PROJECT_ID = typeof import.meta !== 'undefined' && import.meta.env 
  ? import.meta.env.GOOGLE_CLOUD_PROJECT 
  : process.env.GOOGLE_CLOUD_PROJECT;
```

**Why?**
- Astro uses `import.meta.env` at build time
- Node.js uses `process.env` at runtime
- This pattern works in both contexts

---

## üóÑÔ∏è Database Architecture

### Firestore Collections

```typescript
// src/lib/firestore.ts
export const COLLECTIONS = {
  CONVERSATIONS: 'conversations',           // Agent conversations
  MESSAGES: 'messages',                     // Chat messages
  FOLDERS: 'folders',                       // Organization
  USER_CONTEXT: 'user_context',            // User-specific context
  USERS: 'users',                          // User management
  GROUPS: 'groups',                        // Team groups
  CONTEXT_ACCESS_RULES: 'context_access_rules', // Permissions
  CONTEXT_SOURCES: 'context_sources',      // Documents for context
} as const;
```

### Data Models

#### Conversation
```typescript
interface Conversation {
  id: string;
  userId: string;
  title: string;
  folderId?: string;
  createdAt: Date;
  updatedAt: Date;
  lastMessageAt: Date;
  messageCount: number;
  contextWindowUsage: number;              // 0-100%
  agentModel: string;                      // 'gemini-2.5-flash' | 'gemini-2.5-pro'
  activeContextSourceIds?: string[];       // Active context for this agent
}
```

#### Message
```typescript
interface Message {
  id: string;
  conversationId: string;
  userId: string;
  role: 'user' | 'assistant' | 'system';
  content: MessageContent;
  timestamp: Date;
  tokenCount: number;
  contextSections?: ContextSection[];      // What context was used
}
```

#### Context Source
```typescript
interface ContextSource {
  id: string;
  userId: string;
  name: string;
  type: 'pdf' | 'csv' | 'excel' | 'word' | 'web-url' | 'api' | 'folder';
  enabled: boolean;
  status: 'active' | 'processing' | 'error' | 'disabled';
  addedAt: Date;
  extractedData?: string;                  // Extracted text/content
  metadata?: {
    originalFileName?: string;
    originalFileSize?: number;
    workflowId?: string;
    extractionDate?: Date;
    extractionTime?: number;
    model?: string;
    charactersExtracted?: number;
    tokensEstimate?: number;
    pageCount?: number;
    validated?: boolean;                    // Expert sign-off
    validatedBy?: string;
    validatedAt?: Date;
  };
  error?: {
    message: string;
    details?: string;
    timestamp: Date;
    suggestions?: string[];                 // Troubleshooting steps
  };
  progress?: {
    stage: 'uploading' | 'processing' | 'complete' | 'error';
    percentage: number;
    message: string;
  };
}
```

---

## üö® Critical Rules & Lessons Learned

### 1. ‚úÖ ALWAYS Use Correct Gemini API

**‚ùå WRONG:**
```typescript
import { GoogleGenerativeAI } from '@google/genai'; // Class doesn't exist
const genAI = new GoogleGenerativeAI(apiKey);       // Wrong constructor
const model = genAI.getGenerativeModel({...});      // Method doesn't exist
```

**‚úÖ CORRECT:**
```typescript
import { GoogleGenAI } from '@google/genai';        // Correct class
const genAI = new GoogleGenAI({ apiKey });          // Object with apiKey
const result = await genAI.models.generateContent({ // Correct method
  model: 'gemini-2.5-flash',
  contents: message,
  config: { systemInstruction, temperature }
});
const text = result.text || '';                     // Always fallback
```

**Reference:** `.cursor/rules/gemini-api-usage.mdc`

---

### 2. ‚úÖ NEVER Use Mock Mode as Fallback

**‚ùå WRONG:**
```typescript
try {
  const data = await fetch('/api/conversations');
} catch (error) {
  setUseMockData(true); // ‚ùå Auto-enables mock mode
}
```

**‚úÖ CORRECT:**
```typescript
try {
  const data = await fetch('/api/conversations');
} catch (error) {
  console.error('API error:', error);
  setConversations([]); // ‚úÖ Show empty, keep real API
}
```

**Why?**
- Mock mode should be explicit developer choice
- Production errors should not silently switch to mock data
- Users should see real state (empty vs error)

---

### 3. ‚úÖ ALWAYS Handle Firestore Unavailable Gracefully

**Pattern for Required Data:**
```typescript
export async function getConversations(userId: string) {
  try {
    const snapshot = await firestore
      .collection(COLLECTIONS.CONVERSATIONS)
      .where('userId', '==', userId)
      .get();
    return snapshot.docs.map(doc => doc.data());
  } catch (error) {
    console.error('‚ùå Firestore error:', error);
    console.warn('üí° Run: gcloud auth application-default login');
    console.warn('üí° Ensure GOOGLE_CLOUD_PROJECT is set in .env');
    
    // Return empty array instead of crashing
    return [];
  }
}
```

**Pattern for Optional Analytics:**
```typescript
export async function trackEvent(userId: string, event: string) {
  const IS_DEVELOPMENT = import.meta.env.DEV;
  
  if (IS_DEVELOPMENT) {
    console.log('üìù [DEV] Would track event:', { userId, event });
    return; // ‚úÖ Skip in development
  }
  
  try {
    await bigquery.dataset(DATASET_ID).table('events').insert({
      userId,
      event,
      timestamp: new Date()
    });
  } catch (error) {
    console.error('‚ö†Ô∏è Analytics error (non-critical):', error);
    // Don't throw - analytics failure shouldn't break app
  }
}
```

---

### 4. ‚úÖ ALWAYS Persist to GCP, NOT Local State

**‚ùå WRONG:**
```typescript
const [conversations, setConversations] = useState([]);
// Data only in memory, lost on refresh
```

**‚úÖ CORRECT:**
```typescript
const [conversations, setConversations] = useState([]);

// Load from Firestore
useEffect(() => {
  loadConversations();
}, []);

async function loadConversations() {
  const data = await fetch('/api/conversations?userId=' + userId);
  setConversations(await data.json());
}

// Save to Firestore
async function createConversation(title: string) {
  const response = await fetch('/api/conversations', {
    method: 'POST',
    body: JSON.stringify({ userId, title })
  });
  const newConv = await response.json();
  setConversations(prev => [newConv, ...prev]); // Update local state
}
```

**Why?**
- Data persists across sessions
- Syncs across devices
- No data loss on page refresh
- Production-ready from day one

---

### 5. ‚úÖ ALWAYS Use Same GCP Project Everywhere

**Project Configuration:**
```bash
# .env file (SINGLE SOURCE OF TRUTH)
GOOGLE_CLOUD_PROJECT=gen-lang-client-0986191192
```

**Verification:**
```typescript
// src/lib/firestore.ts
const PROJECT_ID = process.env.GOOGLE_CLOUD_PROJECT;
console.log('üîß Firestore Project:', PROJECT_ID);

// src/lib/analytics.ts
const bigquery = new BigQuery({
  projectId: process.env.GOOGLE_CLOUD_PROJECT
});
console.log('üìä BigQuery Project:', PROJECT_ID);
```

**Why?**
- All resources in one project
- Easier billing management
- Simpler IAM permissions
- Consistent configuration

**Reference:** `.cursor/rules/gcp-project-consistency.mdc`

---

## üì° API Route Patterns

### Standard API Route Structure

```typescript
// src/pages/api/resource/[id].ts
import type { APIRoute } from 'astro';
import { verifyJWT } from '../../../lib/auth';
import { getResource } from '../../../lib/firestore';

export const GET: APIRoute = async ({ params, request, cookies }) => {
  // 1. Authentication
  const token = cookies.get('flow_session')?.value;
  if (!token) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const session = verifyJWT(token);
  if (!session) {
    return new Response(JSON.stringify({ error: 'Invalid session' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  // 2. Validate parameters
  const { id } = params;
  if (!id) {
    return new Response(JSON.stringify({ error: 'Resource ID required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  // 3. Fetch data with error handling
  try {
    const resource = await getResource(id);
    
    if (!resource) {
      return new Response(JSON.stringify({ error: 'Resource not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // 4. Authorization check
    if (resource.userId !== session.id) {
      return new Response(JSON.stringify({ error: 'Forbidden' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // 5. Return success
    return new Response(JSON.stringify(resource), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Error fetching resource:', error);
    
    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
};

export const POST: APIRoute = async ({ request, cookies }) => {
  // Similar pattern for creating resources
};
```

### Error Response Standards

```typescript
// 400 - Bad Request (invalid parameters)
{
  error: 'Validation error',
  details: 'userId is required',
  field: 'userId'
}

// 401 - Unauthorized (not authenticated)
{
  error: 'Unauthorized',
  details: 'No session token provided'
}

// 403 - Forbidden (authenticated but not allowed)
{
  error: 'Forbidden',
  details: 'You do not have permission to access this resource'
}

// 404 - Not Found
{
  error: 'Not found',
  details: 'Conversation with ID abc123 does not exist'
}

// 500 - Internal Server Error
{
  error: 'Internal server error',
  details: 'Firestore connection failed',
  suggestions: [
    'Verify GOOGLE_CLOUD_PROJECT is set',
    'Run: gcloud auth application-default login',
    'Check Firestore permissions'
  ]
}
```

---

## üîß Local Development Setup

### Prerequisites

```bash
# 1. Install Node.js 20+
node --version  # Should be 20.x or higher

# 2. Install Google Cloud CLI
gcloud --version

# 3. Authenticate with Google Cloud
gcloud auth login
gcloud auth application-default login

# 4. Set active project
gcloud config set project gen-lang-client-0986191192
```

### Environment Setup

```bash
# .env file (create in project root)
GOOGLE_CLOUD_PROJECT=gen-lang-client-0986191192
GOOGLE_AI_API_KEY=AIzaSy...                    # Get from AI Studio
GOOGLE_CLIENT_ID=...apps.googleusercontent.com  # OAuth credentials
GOOGLE_CLIENT_SECRET=GOCSPX-...
JWT_SECRET=...                                   # Generate with: openssl rand -base64 32
PUBLIC_BASE_URL=http://localhost:3000
NODE_ENV=development
```

### Install Dependencies

```bash
npm install
```

### Run Development Server

```bash
npm run dev
# Server starts on http://localhost:3000
```

### Verify Firestore Connection

```bash
# Test endpoint
curl http://localhost:3000/api/health/firestore

# Expected response:
{
  "status": "healthy",
  "checks": {
    "projectId": { "status": "pass", "value": "gen-lang-client-0986191192" },
    "authentication": { "status": "pass" },
    "connection": { "status": "pass" }
  }
}
```

---

## üöÄ Production Deployment

### Pre-Deployment Checklist

```bash
# 1. Type check (must pass with 0 errors)
npm run type-check

# 2. Build (must succeed)
npm run build

# 3. Verify environment
echo $GOOGLE_CLOUD_PROJECT
# Must output: gen-lang-client-0986191192

# 4. Verify gcloud project
gcloud config get-value project
# Must output: gen-lang-client-0986191192
```

### Deployment Method

```bash
# Set correct project
gcloud config set project gen-lang-client-0986191192

# Deploy to Cloud Run (build happens in GCP)
gcloud run deploy flow-production \
  --source . \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated \
  --min-instances=1 \
  --max-instances=10 \
  --memory=512Mi \
  --cpu=1 \
  --timeout=60s \
  --set-env-vars="GOOGLE_CLOUD_PROJECT=gen-lang-client-0986191192,NODE_ENV=production"
```

### Post-Deployment Verification

```bash
# 1. Get service URL
gcloud run services describe flow-production \
  --region us-central1 \
  --format='value(status.url)'

# 2. Test health endpoint
curl https://flow-production-xxx.run.app/api/health/firestore

# 3. Test in browser
open https://flow-production-xxx.run.app/chat
```

---

## üõ°Ô∏è Error Handling Best Practices

### 1. Categorize Errors

```typescript
try {
  await operation();
} catch (error) {
  let errorMessage = 'Operation failed';
  let suggestions: string[] = [];
  
  if (error instanceof Error) {
    const msg = error.message;
    
    // API Key errors
    if (msg.includes('API key') || msg.includes('GEMINI_API_KEY')) {
      errorMessage = 'Gemini API Key not configured';
      suggestions = [
        'Verify GEMINI_API_KEY in .env file',
        'Restart server after adding key',
        'Confirm key is valid at https://aistudio.google.com/app/apikey'
      ];
    }
    
    // Network errors
    else if (msg.includes('network') || msg.includes('ENOTFOUND')) {
      errorMessage = 'Network connection error';
      suggestions = [
        'Check internet connection',
        'Verify firewall settings',
        'Try again in a few moments'
      ];
    }
    
    // Quota errors
    else if (msg.includes('quota') || msg.includes('rate limit')) {
      errorMessage = 'API quota exceeded';
      suggestions = [
        'Wait a few minutes before retrying',
        'Check quota at https://console.cloud.google.com/',
        'Consider upgrading your plan'
      ];
    }
  }
  
  return new Response(JSON.stringify({
    error: errorMessage,
    details: error instanceof Error ? error.message : 'Unknown error',
    suggestions
  }), { status: 500 });
}
```

### 2. Log Helpfully

```typescript
// ‚úÖ GOOD: Contextual, actionable logs
console.error('‚ùå Failed to create conversation');
console.error('üìã User ID:', userId);
console.error('üìã Title:', title);
console.error('üí° Check Firestore permissions');
console.error('üí° Run: gcloud auth application-default login');
console.error('üîç Error details:', error);

// ‚ùå BAD: Vague, unhelpful logs
console.log(error);
```

### 3. Provide Recovery Paths

```typescript
// In UI error display
<div className="bg-red-50 border border-red-200 rounded p-4">
  <p className="font-semibold text-red-800">Error: {error.message}</p>
  {error.suggestions && (
    <div className="mt-2">
      <p className="text-sm font-medium text-red-700">Possible solutions:</p>
      <ul className="text-sm text-red-600 list-disc ml-4 mt-1">
        {error.suggestions.map((s, i) => (
          <li key={i}>{s}</li>
        ))}
      </ul>
    </div>
  )}
  <button
    onClick={() => retryOperation()}
    className="mt-3 px-3 py-1 bg-red-600 text-white rounded text-sm"
  >
    Retry
  </button>
</div>
```

---

## üìä Data Flow Patterns

### Creating a Conversation

```
1. User clicks "New Agent"
   ‚Üì
2. Frontend: POST /api/conversations
   {
     userId: "user_id",
     title: "New Conversation"
   }
   ‚Üì
3. API validates token
   ‚Üì
4. API creates in Firestore
   firestore.collection('conversations').doc().set({
     userId, title, createdAt, ...
   })
   ‚Üì
5. API returns conversation
   { id, userId, title, createdAt, ... }
   ‚Üì
6. Frontend updates state
   setConversations([newConv, ...conversations])
   ‚Üì
7. Frontend navigates to conversation
   navigate('/chat?conversationId=' + newConv.id)
```

### Sending a Message

```
1. User types message and clicks Send
   ‚Üì
2. Frontend: POST /api/conversations/{id}/messages
   {
     userId: "user_id",
     message: "User question",
     model: "gemini-2.5-flash",
     systemPrompt: "You are...",
     activeContextSourceIds: ["src1", "src2"]
   }
   ‚Üì
3. API validates token + conversation ownership
   ‚Üì
4. API loads conversation context
   const context = await loadConversationContext(conversationId)
   ‚Üì
5. API generates AI response
   const aiResponse = await gemini.generateContent({
     model: "gemini-2.5-flash",
     contents: buildContents(message, context),
     config: { systemInstruction: systemPrompt }
   })
   ‚Üì
6. API saves both messages to Firestore
   await addMessage(conversationId, userId, 'user', message, ...)
   await addMessage(conversationId, userId, 'assistant', aiResponse, ...)
   ‚Üì
7. API returns response with token stats
   {
     userMessage: {...},
     assistantMessage: {...},
     tokenStats: {
       inputTokens: 1234,
       outputTokens: 567,
       contextWindowUsed: 1801,
       contextWindowAvailable: 998199
     }
   }
   ‚Üì
8. Frontend updates messages state
   setMessages([...messages, userMsg, aiMsg])
   ‚Üì
9. Frontend logs context usage
   setContextLogs([...contextLogs, newLog])
```

---

## üß™ Testing Strategies

### Unit Tests (Firestore Functions)

```typescript
// test/lib/firestore.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { createConversation, getConversation } from '../src/lib/firestore';

describe('Firestore Operations', () => {
  it('should create a conversation', async () => {
    const conv = await createConversation('user123', 'Test Conversation');
    
    expect(conv).toBeDefined();
    expect(conv.userId).toBe('user123');
    expect(conv.title).toBe('Test Conversation');
    expect(conv.messageCount).toBe(0);
  });
  
  it('should retrieve a conversation by ID', async () => {
    const created = await createConversation('user123', 'Test');
    const retrieved = await getConversation(created.id);
    
    expect(retrieved).toBeDefined();
    expect(retrieved?.id).toBe(created.id);
  });
});
```

### Integration Tests (API Routes)

```typescript
// test/api/conversations.test.ts
import { describe, it, expect } from 'vitest';

describe('Conversations API', () => {
  it('should create conversation via API', async () => {
    const response = await fetch('http://localhost:3000/api/conversations', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': 'flow_session=valid_token'
      },
      body: JSON.stringify({
        userId: 'user123',
        title: 'API Test Conversation'
      })
    });
    
    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.id).toBeDefined();
    expect(data.title).toBe('API Test Conversation');
  });
  
  it('should reject unauthorized requests', async () => {
    const response = await fetch('http://localhost:3000/api/conversations', {
      method: 'POST',
      body: JSON.stringify({ userId: 'user123', title: 'Test' })
    });
    
    expect(response.status).toBe(401);
  });
});
```

### Manual Testing Checklist

```markdown
### Backend Functionality Tests

#### Authentication
- [ ] Can login with Google OAuth
- [ ] Session persists across page refresh
- [ ] Logout clears session
- [ ] Unauthorized requests return 401

#### Conversations
- [ ] Can create new conversation
- [ ] Conversations persist after refresh
- [ ] Can load conversation history
- [ ] Can delete conversation (and its messages)
- [ ] Conversations appear in correct folder

#### Messages
- [ ] Can send message
- [ ] AI responds correctly
- [ ] Messages persist after refresh
- [ ] Context is applied to AI responses
- [ ] Token stats are accurate

#### Context Sources
- [ ] Can upload PDF
- [ ] Extraction completes successfully
- [ ] Extracted text is accurate
- [ ] Can toggle source on/off
- [ ] Active sources affect AI responses
- [ ] Source settings are per-conversation

#### Data Persistence
- [ ] All data saves to Firestore
- [ ] No data loss on page refresh
- [ ] No data loss on browser close
- [ ] Data syncs across tabs
- [ ] Data available after redeployment
```

---

## üîÑ Common Operations

### Update User's Last Login

```typescript
// In OAuth callback
export const GET: APIRoute = async ({ url, cookies }) => {
  // ... OAuth flow ...
  
  // After successful login
  await updateLastLogin(user.id);
  
  // ...
};
```

### Track Context Usage

```typescript
// After each AI response
const tokenStats = {
  inputTokens: 1234,
  outputTokens: 567,
  contextWindowUsed: 1801,
  contextWindowAvailable: 998199,
  contextWindowCapacity: 1000000,
};

// Update conversation
await updateConversation(conversationId, {
  contextWindowUsage: (tokenStats.contextWindowUsed / tokenStats.contextWindowCapacity) * 100
});

// Log to BigQuery (optional, non-blocking)
try {
  await trackChatInteraction({
    userId,
    conversationId,
    model: 'gemini-2.5-flash',
    inputTokens: tokenStats.inputTokens,
    outputTokens: tokenStats.outputTokens,
    timestamp: new Date()
  });
} catch (error) {
  console.warn('‚ö†Ô∏è Analytics tracking failed (non-critical):', error);
}
```

### Save Agent-Specific Context

```typescript
// When user toggles context sources
async function handleContextToggle(sourceId: string, enabled: boolean) {
  // Update local state
  const updatedSources = contextSources.map(s =>
    s.id === sourceId ? { ...s, enabled } : s
  );
  setContextSources(updatedSources);
  
  // Save to Firestore (persists across sessions)
  const activeIds = updatedSources
    .filter(s => s.enabled)
    .map(s => s.id);
  
  await saveConversationContext(currentConversation, activeIds);
}

// When loading a conversation
async function loadConversation(conversationId: string) {
  // Load conversation
  const conv = await getConversation(conversationId);
  
  // Load messages
  const msgs = await getMessages(conversationId);
  
  // Load and apply context sources
  const activeIds = await loadConversationContext(conversationId);
  const updatedSources = allContextSources.map(s => ({
    ...s,
    enabled: activeIds.includes(s.id)
  }));
  
  setConversation(conv);
  setMessages(msgs);
  setContextSources(updatedSources);
}
```

---

## üìö Reference Documentation

### Internal Docs
- `docs/LocalToProduction.md` - Complete deployment guide
- `docs/CHAT_INTEGRATION_LESSONS.md` - Lessons learned
- `docs/GEMINI_API_MIGRATION.md` - Gemini AI guide
- `TEST_ERROR_HANDLING.md` - Error handling testing
- `.cursor/rules/gemini-api-usage.mdc` - Gemini API rules
- `.cursor/rules/gcp-project-consistency.mdc` - GCP project rules

### External Docs
- [Firestore Node.js Client](https://cloud.google.com/nodejs/docs/reference/firestore/latest)
- [BigQuery Node.js Client](https://cloud.google.com/nodejs/docs/reference/bigquery/latest)
- [Gemini AI API](https://ai.google.dev/api)
- [Astro API Routes](https://docs.astro.build/en/core-concepts/endpoints/)

---

## ‚úÖ Success Criteria

A properly implemented backend should:

1. **Data Persistence**
   - ‚úÖ All user data saves to Firestore
   - ‚úÖ No data loss on page refresh
   - ‚úÖ Data survives redeployments

2. **Error Handling**
   - ‚úÖ Graceful degradation when services unavailable
   - ‚úÖ Helpful error messages with recovery steps
   - ‚úÖ No silent failures

3. **Performance**
   - ‚úÖ API responses < 3 seconds (p95)
   - ‚úÖ Firestore queries optimized with indexes
   - ‚úÖ Analytics don't block main operations

4. **Security**
   - ‚úÖ All API routes require authentication
   - ‚úÖ Users only see their own data
   - ‚úÖ Role-based permissions enforced

5. **Consistency**
   - ‚úÖ Local dev matches production behavior
   - ‚úÖ Same GCP project everywhere
   - ‚úÖ Environment variables documented

---

**Last Updated**: 2025-10-12
**Version**: 1.0.0
**Status**: ‚úÖ Production Ready
